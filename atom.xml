<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>同理，显然，略……</title>
  
  <subtitle>还没想好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://momingcoder.github.io/"/>
  <updated>2018-01-09T10:02:54.816Z</updated>
  <id>https://momingcoder.github.io/</id>
  
  <author>
    <name>Moming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通向财富自由之路</title>
    <link href="https://momingcoder.github.io/2018/01/09/%E9%80%9A%E5%90%91%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
    <id>https://momingcoder.github.io/2018/01/09/通向财富自由之路/</id>
    <published>2018-01-09T07:28:38.000Z</published>
    <updated>2018-01-09T10:02:54.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们活着是为了什么？</p></blockquote><p>这个哲学问题太难了，换个简单一点的。</p><blockquote><p>怎么活着比较爽啊？</p></blockquote><p>显然，如果能实现财富自由的话，生活就能过得比较爽了，毕竟世界上 99.99% 的事情都可以通过钱来解决。实现财富自由之后，日子就爽多了，可以做自己喜欢的事情，哪怕你现在做的就是你喜欢的事情，解决钱的问题也会让你过得更爽。</p><p>首先，三省吾身：“能够继承巨额财富吗？有条件吃几十年的软饭吗？当年买比特币了吗？”。</p><p>如果都是否的话，那就可以继续往下看了。</p><h2 id="程序员要怎么走"><a class="markdownIt-Anchor" href="#程序员要怎么走"></a> 程序员要怎么走</h2><h3 id="工作"><a class="markdownIt-Anchor" href="#工作"></a> 工作</h3><p>想要靠工资实现财富自由的可能性，可能性跟买彩票差不多。</p><p>另一方面，想要通过股票实现财富自由，大概还是有可能的。前提是，你跑去跟别人一起创业，或者在创业公司的刚起步的时候加入，然后事实证明你押对了。</p><p>基本上就像《黑客与画家》中写的那样，老板是不可能因为你做出了 10 个人头的贡献，就给你 10 倍工资，能给你 3 倍就已经是不错了。基本上，想要实现回报大约匹配的上自己的付出，那就只能走创业的道路了。</p><p>创业这条路，能存活的概率似乎也跟买彩票差不多。首先，靠谱的合作伙伴就很难找了。之后，创业的方向，技术选择，市场推广，员工招聘，品牌经营，等等，这里面的坑太多了。好处就是，万一功成名就，那真的是人生一大成就。</p><h3 id="side-project"><a class="markdownIt-Anchor" href="#side-project"></a> Side Project</h3><p>自己做一个好玩的项目，然后长期维护。假如项目真的有不少人用，收取点咨询费差不多也能过得滋润了。</p><p>通常，项目的出发点是自己的兴趣或者自己的需要，这未必符合大众的需求，也可能早就有了更好的实现而你不知道，也可能是自己写的太烂没法用。</p><p>不过，最难的地方在于，动手写。懒是最大的障碍，而且这个东西也没有 Deadline 这种强大的推动力，所以结果可想而知了。</p><p>很多 side project 到最后也很难真正盈利，靠着大家补贴的一点钱可没办法过得好，纯粹是靠着个人的兴趣和情怀在支撑。</p><p>估算一下成功率，估计也是一样低。</p><h3 id="培训"><a class="markdownIt-Anchor" href="#培训"></a> 培训</h3><p>任何一个看似火爆的行业，都不会缺培训班的。</p><p>大家其实还是很抵制编程的培训班的，毕竟质量太差，教出来的学生多数也都没法正常就业，理论知识薄弱，遇到问题没法正确处理。</p><p>但是不得不承认，这个行业盈利真的可怕，招生也非常容易，大概做到新东方那个体量就可以财富自由了 ：）。</p><p>这个方向也是有靠谱的东西的，现在 MOOC 还是很有前景的，专注于某个方向开一门课，其实也可以做到传播真正靠谱的知识，被同行认可。不过通常需要你先有一个吓唬人的 title ，什么大厂的高级什么开发，什么名校的什么教授之类的，门槛比较高。</p><p>当然，没有足够的 title 也完全可以走自媒体的道路。自己写高质量的文章，制作高质量的视频，慢慢积攒人气，也能够成为靠流量吃饭的人。</p><h3 id="自媒体"><a class="markdownIt-Anchor" href="#自媒体"></a> 自媒体</h3><p>这年头自媒体真的是太火了，不过业内自媒体质量大多非常差，有价值的屈指可数。</p><p>这条路就很考验能否迎合大众需求了。比如你现在跟风写区块链，深度学习，那怎么说也比写形式语言方面的流量多吧。当然，质量也是很重要的。不过很多时候，你写的很深很专业，也可能适得其反，大众还是喜欢快餐，太过深奥的东西，也只能留给业内高手互相切磋了。通常，入门的东西常常能带来最多的流量，适当添加一些有深度的东西即可。</p><p>业内高手还是挺多的，但是能用把复杂的东西讲得简单易懂，就很难了。很多觉得一看就懂的东西，可能小白想破脑袋都想不明白。而理论知识和实践分别占多大比重，也是一个很重要的问题。</p><h3 id="一条龙"><a class="markdownIt-Anchor" href="#一条龙"></a> 一条龙</h3><p>什么叫一条龙呢？</p><p>有了一个点子，开始拉伙儿创业，找投资找不到，直接散伙儿。</p><p>开始当做自己的 Side Project ，努力做，然后发现，不行啊，推广不出去，大家都不喜欢。</p><p>转头搞培训，给别人讲你的技术，踩过的坑。然后发现，不行啊，大家不买账，付款的太少。</p><p>然后开始运营自媒体，写自己的经历，写自己的感悟。然后发现，看客太少，东西没多少深度，养活不了自己。</p><p>走到最后了，开始利用自己丰富的经验，忽悠年轻人，“小伙子，不要总想着拿一份死工资，你那样是没法成功的，怎么样，来跟我混吧！”</p><h3 id="搞比赛"><a class="markdownIt-Anchor" href="#搞比赛"></a> 搞比赛</h3><p>Kaggle 之类的，现在国内也有很多了，几乎是不断有新比赛。</p><p>以前大家都在搞 ACM，现在变成都在搞机器学习了，估计是看起来更实际，更容易转化成产品吧。</p><p>这条路还是看着比较靠谱的，门槛可能在于你有没有足够的计算资源，之后基本就靠堆时间了。通常来说，只要有充足的时间，就算拿不到金牌，起码也是有不错的名次的，毕竟 Kernel 和 Discuss 都写的那么详细了，XGBoost 和 Sickit-Learn 又是那么好用，深度学习也比较容易搞，总的来说还是只要肯下功夫，肯定会有收获。</p><p>有了好名次之后，相当于自己也有了个 title，出去忽悠忽悠也是可以的，然后干嘛请参考上面。</p><p>至于靠比赛奖金度日靠不靠谱，不好说，开销不大又很能调优的话，估计应该不成问题。</p><h3 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h3><p>大家都知道财富自由是多么遥远。不管是那种暴发户式的，还是细水长流的，都需要足够的努力和极好的运气。</p><p>且行且珍惜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们活着是为了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个哲学问题太难了，换个简单一点的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;怎么活着比较爽啊？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然，如果能实现财富自由的话，生活就能过得比
      
    
    </summary>
    
      <category term="生活" scheme="https://momingcoder.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://momingcoder.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="兴趣" scheme="https://momingcoder.github.io/tags/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>2018 做点什么</title>
    <link href="https://momingcoder.github.io/2018/01/01/2018-%E5%81%9A%E7%82%B9%E4%BB%80%E4%B9%88/"/>
    <id>https://momingcoder.github.io/2018/01/01/2018-做点什么/</id>
    <published>2018-01-01T09:52:28.000Z</published>
    <updated>2018-01-09T16:36:15.683Z</updated>
    
    <content type="html"><![CDATA[<p>这篇当然不是 2018 第一天写的，毕竟这一年已经懒了太多了。写这篇的目的，无非就是总结一下自己的 2017，然后展望下自己的 2018 。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>回顾这一年，最大的体会就是一个字：“懒”。</p><p>早上睡到 7 点半，周末睡到 8,9 点，周末下午一个午休基本就到晚上了。</p><p>读书少了，Kindle 又开始长期吃灰了，基本只有坐车回家的时候才会看看。技术类书籍也没耐心看了，很多都只是开了个头就放着了。</p><p>锻炼少了，偶尔去打一次球，Keep 也很难坚持下去，稍微累一点就想着算了。</p><p>宅的可怕，偶尔出去接触下人群，让自己适应下一堆活人熙熙攘攘的环境。</p><p>MOOC 基本不看了，再也没有之前那种每周积极学习的劲头了。</p><p>Kaggle 什么的，看了一点，完全没有认真做过。</p><p>至于长进，没有太多，基本就是按部就班的事情，攒够经验就升级的那种，实在没什么值得写下来的。</p><h3 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h3><p>坚持写博客吧，总算是搭起来开始写了，虽然基本都是吐槽瞎扯的。希望 18 年在吐槽之余，能多写几篇技术相关的，记好笔记，写好总结。</p><p>睡觉的问题，可能跟上班了不能随便补觉有关吧，晚起不要紧，周末还是应该抓紧时间学习的，或者就出去转转，感受下人类的生活？</p><p>读书这件事情没有商量的余地了，必须认真读了。不管是技术类还是文学作品，至少应该读够 10 本。</p><p>锻炼身体，远离感冒。最近这场几乎全球性的流感实在太可怕了，身体不好的话感觉能一病几个月。运动量不必太大，能保持现在的体型就行，最好再长点肉，也要多注意膝盖。</p><p>MOOC 还是应该捡起来的，或者直接读相关著作。</p><p>Kaggle 什么的，还是要认真做几次，调整好心态，就是一个人的战斗，别期望有什么队友了，这都多少年了，你见到队友了？</p><p>开源社区的贡献，代码也好，翻译也好，总之要动手了。</p><p>Rust 写点东西，不能只会用 Python 搞搞机器学习深度学习什么的，前后端的能力也都比较基础，可以适当再提升下。</p><h3 id="hope"><a class="markdownIt-Anchor" href="#hope"></a> Hope</h3><p>希望 TODO 不仅仅是 TODO 吧，最好都能落实。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇当然不是 2018 第一天写的，毕竟这一年已经懒了太多了。写这篇的目的，无非就是总结一下自己的 2017，然后展望下自己的 2018 。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#总结&quot;&gt;&lt;/a&gt; 总结&lt;/h
      
    
    </summary>
    
      <category term="生活" scheme="https://momingcoder.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="todo" scheme="https://momingcoder.github.io/tags/todo/"/>
    
      <category term="总结" scheme="https://momingcoder.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Rust 略详细的介绍</title>
    <link href="https://momingcoder.github.io/2017/12/22/Rust-%E7%95%A5%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://momingcoder.github.io/2017/12/22/Rust-略详细的介绍/</id>
    <published>2017-12-22T15:02:49.000Z</published>
    <updated>2018-01-09T16:16:59.383Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 是一门编译型系统编程语言。官方给出的定义是：</p><blockquote><p><strong>Rust</strong> is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p></blockquote><p>可以看出这是一门主打效率，安全和并发的语言。</p><p>Rust 有着接近 C 的效率，具体的对比可以从 <a href="http://benchmarksgame.alioth.debian.org/u64q/rust.html" target="_blank" rel="external">Benchmarksgame</a> 上看到。有人说这会是一门替代 C/C++ 的语言，这一点很难说，但是可以肯定这是一门很不错的语言，绝对值得一学。</p><p>在安全方面，更多的是本身的设计做保障，生命周期，所有权等，这些下面会详细介绍。基本上，如果你没用到 Rust 中那些不够安全的东西的话，所有的安全问题都可以在编译阶段被检查出来，防止运行中发生问题。</p><p>Rust 的无畏并发，得益于本身的设计解决了大部分数据读写的冲突，使得并发的效率惊人的高。</p><p>下面很多代码都是官方的文档中复制过来的，挑的都是根据这篇介绍就可以看懂的。</p><h3 id="出身"><a class="markdownIt-Anchor" href="#出身"></a> 出身</h3><p>Rust 是由 Mozilla 主导开发的，1.0 版本于 2015 年 5 月 15 发布，是一门非常年轻的语言，但是它有着相当友好的社区支持，非常棒的错误提示，优秀的设计理念，即使有着相对较高的门槛，也深受开发者喜爱，在 <a href="https://insights.stackoverflow.com/survey/2016" target="_blank" rel="external">StackOverflow 2016 survey</a>   <a href="https://insights.stackoverflow.com/survey/2017" target="_blank" rel="external">StackOverflow 2017 survey</a>  上都是最受喜爱的语言，也许高门槛帮它过滤了很多不必要的负面的东西吧。</p><p>另外，Rust 的吉祥物是一只橙色的螃蟹，大概是生锈的螃蟹？</p><h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3><p>Mozilla 首先利用 Rust 开发了一个浏览器引擎 <a href="https://github.com/servo/servo" target="_blank" rel="external">servo</a> ，Firefox Quantum 的崛起正是得益于 Rust 的高性能和并行特性。</p><p>既然是系统编程语言，少不了有人用它写操作系统，这便是 <a href="https://github.com/redox-os/redox" target="_blank" rel="external">Redox OS</a> ，目前已经是一个有着诸多功能的操作系统，感兴趣的可以安装试玩。这个操作系统也用到了新的文件系统 <a href="https://github.com/redox-os/tfs" target="_blank" rel="external">TFS</a> 。</p><p>Google 有一个文本编辑器 <a href="https://github.com/google/xi-editor" target="_blank" rel="external">xi-editor</a> ，后端就是用 Rust 写的，目前也有几个对应的前端，不过都算不上很成熟。</p><p>目前的命令行工具有 <a href="https://github.com/sharkdp/fd" target="_blank" rel="external">fd</a> ，<a href="https://github.com/ogham/exa" target="_blank" rel="external">exa</a> ，<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="external">ripgrep</a> ，分别对应 <code>find</code> ，<code>ls</code> ，<code>grep</code> 命令，值得一试。</p><p>机器学习这么火，Rust 也有相应的库 <a href="https://github.com/autumnai/leaf" target="_blank" rel="external">Leaf</a> ，不过两年前停止更新了，毕竟这方面 scikit-learn 实在太出色了。</p><p>也有一个 Rust 终端 <a href="https://github.com/jwilm/alacritty" target="_blank" rel="external">Alacritty</a> ，号称是最快的，使用了 GPU 加速，而且是跨平台的。</p><p>有人用 Rust 重写了一份 <a href="https://github.com/uutils/coreutils" target="_blank" rel="external">GNU coreutils</a> 工具，利用了 Rust 跨平台编译的特性，可以方便地将这套工具部署在 Windows 上。</p><p>目前也有一些 Web 框架，像 <a href="https://github.com/SergioBenitez/Rocket" target="_blank" rel="external">Rocket</a> ，听名字就知道性能强悍，微服务框架 <a href="https://github.com/fengsp/pencil" target="_blank" rel="external">pencil</a> ，主打扩展和并发的 <a href="https://github.com/iron/iron" target="_blank" rel="external">iron</a> ，看名字就觉得很 rust。</p><p>分布式 key-value 数据库 <a href="https://github.com/pingcap/tikv" target="_blank" rel="external">TiKV</a> ，<a href="https://www.pingcap.com/en/" target="_blank" rel="external">PingCAP</a> 公司出品，可以对接他们搞的 <a href="https://github.com/pingcap/tidb" target="_blank" rel="external">TiDB</a> 。</p><p>区块链方面，有 <a href="https://github.com/exonum/exonum" target="_blank" rel="external">Exonum</a> 和 <a href="https://github.com/cryptape/cita" target="_blank" rel="external">CITA</a> ，针对 <a href="https://www.ethereum.org/" target="_blank" rel="external">Ethereum</a> 区块链应用平台还有 <a href="https://github.com/paritytech/parity" target="_blank" rel="external">Parity</a> 这样的客户端。</p><p>游戏引擎方面有 <a href="https://github.com/PistonDevelopers/piston" target="_blank" rel="external">Piston</a> 。</p><p>其他项目参考 <a href="https://github.com/rust-unofficial/awesome-rust" target="_blank" rel="external">Awesome List</a> 吧。</p><h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3><p>Rust 在语法上接近 C/C++，但是关键词的缩写为人诟病，在这个编辑器智能补全技术十分成熟的时代，实在没多少必要。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量类型有可变和不可变，这一点和 <code>Scala</code> 类似。</p><p>基本变量类型 <code>int</code> ，<code>float</code> 还能细分各种长度，比如 <code>i16</code> ，<code>u32</code> ，<code>f64</code> 等，整型中间的可以用 <code>_</code> 来作分隔符，比如 <code>100_000</code> 等同于 <code>100000</code> 。char 类型则是完全支持 Unicode 的。高级类型，诸如可容纳不同类型的 tuple，同一类型的 array。</p><p>函数声明中必须明确指定每个变量的类型和返回值的类型。需要注意的是， Statements 只执行操作而没有返回值，Expression 会计算并给出返回值。函数中如果需要返回一个变量，只需要在函数末尾给出相应的表达式并不加 <code>;</code> 即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    x + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>控制流中需要的 <code>bool</code> 类型必须为 <code>bool</code> 类型，而不能使用诸如 <code>0</code> ，<code>1</code> ，<code>[]</code> 等代替。</p><h3 id="cargo"><a class="markdownIt-Anchor" href="#cargo"></a> Cargo</h3><p>Cargo 是 Rust 的一个包管理工具，不过它能够做的不仅仅是包管理。</p><p>（你可以在 <a href="https://crates.io/" target="_blank" rel="external">crate</a> 上找到 Rust 的所有包，相当于 Python 的 PyPI 平台）</p><p>Cargo 的功能非常丰富，如果拿 Python 来作对比的话，大概相当于 <code>pip</code> + <code>setuptools</code> + <code>pipenv</code> + <code>twine</code> 等工具的总和。</p><p>Rust 项目通常都是从 <code>cargo new project_name --bin</code> 开始的。此时会自动生成一个 <code>Cargo.toml</code> 文件，这里面包含项目的信息，以及作者资料，这部分从 Git 中获得，而且会自动执行 <code>git init</code> 。当运行 <code>cargo run</code> 之类的 build 命令时，就会生成 <code>Cargo.lock</code> 文件，其中是项目的依赖，是由 Cargo 根据实际项目生成的，不应该被人为修改。</p><p>Cargo 同样可以用来执行测试，前提是你写了相关的测试，不管是专门的测试代码，还是包含在注释中的测试代码，都可以被执行。</p><p>另外，Cargo 还可以根据注释快速生成文档，并且提供了相应的 Web 服务，可以说是非常方便了。</p><p>其他特征可以参考 <a href="https://doc.rust-lang.org/cargo/" target="_blank" rel="external">Cargo 文档 </a> 。</p><h3 id="trait"><a class="markdownIt-Anchor" href="#trait"></a> Trait</h3><p>trait 有一点类似于其他语言中的 interface ，用于定义类型的一些通用行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summarizable</span></span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个简单的定义，没有给出 <code>summary</code> 方法的默认实现。之后，就可以应用到需要的地方去了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">News</span></span> &#123;</div><div class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</div><div class="line">    <span class="keyword">pub</span> author: <span class="built_in">String</span>,</div><div class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Summarizable <span class="keyword">for</span> News &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summary</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</div><div class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; \n&#123;&#125;"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.content)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>像上面这样，可以将 <code>Summarizable</code> 用到任何需要的地方，这也是利用 Rust 实现 OOP 的重要工具。</p><h3 id="object-oriented-programming"><a class="markdownIt-Anchor" href="#object-oriented-programming"></a> Object Oriented Programming</h3><p>面向对象是一种很常见的模式了，对 Rust 而言，它属于“薛定谔的面向对象”。</p><p>一方面，Rust 拥有结构体 <code>struct</code> 和枚举 <code>enum</code> 以及 <code>impl</code> 方法，理论上讲可以实现类似于面向对象程序设计中的一个对象包含的数据和方法。而 Rust 又是非常谨慎的，不标明 <code>pub</code> 的都是私有数据和方法，因此可以封装实现细节，外部仅能访问 <code>pub</code> 类的数据和方法。</p><p>另一方面，Rust 是不能直接继承的，而是通过为结构体定义通用的 <code>trait</code> 方法，这有点类似于动态语言中的鸭子类型的概念。至于多态，同样可以利用 <code>trait</code> 做到。</p><p>总的来说，Rust 并不是一门纯粹的 OOP 语言，不过你喜欢 OOP 的话也可以用得起来。但是 OOP 有时候并不是那么 “Rustician” 。</p><h3 id="ownership-garbage-collection"><a class="markdownIt-Anchor" href="#ownership-garbage-collection"></a> Ownership &amp; Garbage Collection</h3><p>Rust 是没有垃圾回收机制的，相应的，为了保证内存安全，它有着独一无二的 ownership 。每一个变量都对应有它的 owner，且在任何时候都只能拥有一个 owner （这保证了多线程中的数据安全），当 owner 离开作用域的时候，值就会被丢弃，对应的内存空间就会被释放。可以这样理解，Rust 的垃圾回收是做到极致了，你必须清楚自己用到的每一块内存在什么时候会废弃，而 Rust 就像一个旋涡，一旦你松手，内存就会被它吸进去回收掉。因此，你需要考虑的不是什么时候释放这块内存，而是要把这块内存保留到什么时候。</p><p>对于基本类型，当你使用 <code>x = y</code> 这样的语句时，<code>y</code> 的值会被复制给 <code>x</code> ，他们属于拥有相同值的两个变量。而对于复杂类型，类似 C/C++ ，这样只会把指针内容复制过去，而数据是保持不变的，同时数据的 owner 变为 <code>x</code> ，此时调用 <code>y</code> 则会出错，因为它已经不指向任何内存了。如果你想把数据也复制过去，就需要调用对应的 <code>clone</code> 函数了。</p><p>Rust 中给函数传递复杂类型需要用到引用 <code>&amp;</code> ，除非你想放弃该变量的 ownership 。引用允许函数访问数据但没有 ownership ，权限默认为可读，如果你加了 <code>mut</code> ，则函数可读写借到的数据，当然这要求变量本身是可变类型的，毕竟地主家里都没有余粮，怎么可能借给租户呢？</p><h3 id="functional-programming"><a class="markdownIt-Anchor" href="#functional-programming"></a> Functional Programming</h3><p>Rust 的闭包语法类似于 Smalltalk 和 Ruby，有类型推断和注解，这意味着你不必写全类型，但是用过一次之后便会锁定类型不能再改变了。另外，Rust 的闭包还能够捕获环境变量，这是函数不具有的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">1</span>, z = <span class="number">2</span>;</div><div class="line">    <span class="keyword">let</span> equal2x = |y| y == x;</div><div class="line">    <span class="built_in">assert!</span>(equal2x(z));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Rust 的迭代器跟 Python 一样是惰性的，本身的实现就是不断调用 <code>.next()</code> 方法，同时可以配合闭包创建新的迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    <span class="keyword">let</span> y = <span class="built_in">Vec</span>&lt;_&gt; = x.iter().map(|x| x + <span class="number">1</span>).collect();</div><div class="line">    <span class="built_in">assert!</span>(y, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Rust 的迭代器跟 C++ 一样是零成本抽象的，实际中可能还要比普通的遍历快，所以尽可能使用迭代来提高效率，简化代码吧。</p><h3 id="lifetime"><a class="markdownIt-Anchor" href="#lifetime"></a> Lifetime</h3><p>Rust 中所有的引用都有一个生命周期，通常是可以由编译器推断的，不过有些时候需要我们自己来规定，这大概是 Rust 和其他编程语言最不同的地方了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> r;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</div><div class="line">    r = &amp;x; <span class="comment">// Error</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">println!</span>(<span class="string">"r: &#123;&#125;"</span>, r);</div></pre></td></tr></table></figure><p>编译器中负责这一部分的叫做借用检查器 borrow checker，不要小看它，这可能是 Rust 中最难以深入理解的一部分了。对于每一个变量，借用检查器都会默认给出一个生命周期注解，通常以 <code>'</code> 开头，比如 <code>'a</code> ，当借用检查器发现一个变量引用了一个比自身生命周期小的变量时，就会报错，这里的小是指不能够包含本身。</p><p>生命周期是需要能够明确推断出或者被明确指定的，这一点可以严格保证数据安全。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</div><div class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</div><div class="line">        x</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        y</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大家一定会觉得 Rust 疯了，这么简单的功能需要写的这么复杂吗？是的，很必要。Rust 需要知道生命周期准确的范围，即使像上面这样无法知道准确两个变量的准确范围，那就给他们加上泛型生命周期，保证他们都会在某个特定的作用域中。到这里你会觉得这门语言真的有点麻烦呢，原以为用上 Rust 之后就不必像 C++ 那样到处考虑指针的问题了，但其实 Rust 的生命周期的复杂度也非常高，从门槛上来讲，或许要比 C++ 还复杂。因为你需要实现精准的控制，而不是大概好像就那样吧。</p><h3 id="smart-pointer"><a class="markdownIt-Anchor" href="#smart-pointer"></a> Smart Pointer</h3><p><code>Box&lt;T&gt;</code> 是最简单的智能指针，指针本身存在于栈上，数据则保存在堆中，这一点其实都差不多。Box 是允许创建递归类型的，不过 Rust 本身要求大小必须是明确的，否则存在不安全隐患。</p><p><code>Deref</code> 可以重载 <code>*</code> 解引用运算符，<code>Drop</code> 用来清理代码（Rust 本身会在离开作用域时执行这个），<code>Rc&lt;T&gt;</code> 可以存放引用计数，允许对该类型进行不完全拷贝，来使数据同时有多个所有者，当然这个数据是不可变的。对于可变数据，就需要用到 <code>RefCell&lt;T&gt;</code> 了。这部分仔细讲起来太占地方了，而且我也没有在实际中用过，恐怕写不好，也没有想到什么通俗的例子，大家还是看 <a href="https://doc.rust-lang.org/book/second-edition/ch15-05-interior-mutability.html" target="_blank" rel="external">文档</a> 去吧。</p><p>其实写到这里，多少能感受到 Rust 的门槛了。</p><h3 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency"></a> Concurrency</h3><p>Rust 标准库的线程模型是 1:1 的，即一个 OS 线程对应一个语言线程，这是为了效率考虑的，如果你希望更好的控制线程并减少上下文切换成本，那可以用相应的 crate 中的实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</div><div class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</div><div class="line">    &#125;);</div><div class="line">    handle.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的例子传递了一个闭包给其他线程执行，最后等待所有子线程结束后再结束主线程。</p><p>线程中利用 channel 来进行通信再常见不过了，下面是一个简单的例子，其中也包含着所有权的转移。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"><span class="keyword">use</span> std::sync::mpsc;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</div><div class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</div><div class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</div><div class="line">        tx.send(val).unwrap();  <span class="comment">// the ownership of val is send to rx</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，对于互斥锁，Rust 有专门的 <code>Mutex</code> ，<code>lock</code> 之后会造成阻塞，当离开作用域的时候会自动释放锁。也有专门的原子引用计数 <code>Arc</code> ，当然这些都跟 smart pointer 有关了。想要在线程之间共享变量，势必会存在所有权的问题，所以需要引入引用计数，从而可以 <code>clone</code> 锁，当然这是一种特殊的不完全拷贝。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</div><div class="line"><span class="keyword">use</span> std::thread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</div><div class="line">        <span class="keyword">let</span> counter = counter.clone();</div><div class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</div><div class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</div><div class="line">            *num += <span class="number">1</span>;</div><div class="line">        &#125;);</div><div class="line">        handles.push(handle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</div><div class="line">        handle.join().unwrap();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为 <code>Mutex</code> 提供了内部可变性，即使 <code>counter</code> 不可变，我们依然可以通过获取其内部值的可变引用来实现计数。就好像 Python 中 <code>tuple</code> 是不可变的，但是如果是对 <code>tuple</code> 内部的 <code>list</code> 操作就没问题了。</p><p>此外，Rust 中还有两个重要的并发 trait <code>Send</code> 和 <code>Sync</code> ，前者用来表示所有权可能被传递给其他线程，后者表示多线程访问是安全的。</p><h3 id="unsafe"><a class="markdownIt-Anchor" href="#unsafe"></a> Unsafe</h3><p>Rust 并不是什么都绝对安全，比如上面提到的 Smart Pointer 中的 <code>RefCell&lt;T&gt;</code> ，在编译阶段并不能保证通过就是安全的，而需要用户自己分析。</p><p><a href="https://www.cs.virginia.edu/~bjc8c/papers/levy17rustkernel.pdf" target="_blank" rel="external">The Case for Writing a Kernel in Rust</a> 这篇论文就是关于如何在保证高性能的同时实现一个安全的系统内核，其中当然要处理很多不安全问题，尽可能将不安全的模块封装起来，保证特定情况下的绝对安全，感兴趣的可以看看。</p><h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python？</h3><p>有了如此强悍的性能和安全性，自然想到，应该用到那些需要性能的地方去，还要有友好的借口给其他语言用。</p><p><a href="https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust/" target="_blank" rel="external">Speed Python Using Rust</a> RedHat 的这篇博客写的就很到位了，这里用到了 <a href="https://github.com/dgrunwald/rust-cpython" target="_blank" rel="external">rust-cpython</a> 工具，通过 <a href="https://github.com/rochacbruno/rust-python-example#new-results" target="_blank" rel="external">benchmark</a> 可以看出来，Rust 的优势还是非常明显的，几乎是 pure Python 的 100 倍，跟 C 的实现相比，基本上是一个水平的。</p><p>当然，目前看来这些工具还是有很大的改进空间的，不过我还是很看好未来的发展的。</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>如果要用一个词来评价 Rust，我觉得还是 brilliant 比较合适。它并非用了什么 magic ，只是针对它想解决的问题，走了一条特立独行的路，并合理吸收各种编程语言和工具的长处，从而发展出自己一套特有的哲学，可谓是增之一分则太长，减之一分则太短。</p><p>本文也只是浅显地介绍了一些东西而已，我也没有拿 Rust 写过什么能拿得出手的东西，都只是停留在 TODO list 上。至于底层的一些实现，那更不是我现在能说得清的。等我深入实践过之后，再来写点感悟吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 是一门编译型系统编程语言。官方给出的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Rust&lt;/strong&gt; is a systems programming language that runs blazingly fast, prevent
      
    
    </summary>
    
      <category term="技术" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程语言" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Rust" scheme="https://momingcoder.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>大学这四年</title>
    <link href="https://momingcoder.github.io/2017/12/19/%E5%A4%A7%E5%AD%A6%E8%BF%99%E5%9B%9B%E5%B9%B4/"/>
    <id>https://momingcoder.github.io/2017/12/19/大学这四年/</id>
    <published>2017-12-19T15:10:42.000Z</published>
    <updated>2017-12-19T16:22:03.205Z</updated>
    
    <content type="html"><![CDATA[<p>时光飞逝，还没来得及好好享受，就已经大学毕业了。</p><p>回想这四年的时光，虽然多是无聊的日子，但多少也有一些值得怀念的记忆。</p><h3 id="学习"><a class="markdownIt-Anchor" href="#学习"></a> 学习</h3><p>一开始我是没这个打算的。好不容易有时间打游戏了，学习什么的，能及格就可以了吧。</p><p>半年后拥有了自己的电脑，准系统的性能足够我玩任何想玩的游戏了。一定要说限制因素的话，大概就是信息吧。自己习惯了一个人玩，能找的资源无非就是盗版单机，国产网游什么的，体验很差，一些情怀也很快就耗尽了。我实在没可能沉迷游戏，即使是后来接触 Steam 玩正版，单机角色扮演只刷刷剧情，网游完全没兴趣，手游看到坑就跑，好像也就 NBA2K 玩得比较多吧。</p><p>那时候感到特别无聊，无聊到去机房写代码。本身对代码有点兴趣，还想着要不要写个刷怪的脚本什么的。一开始确实被各种初级 ACM 题目虐，熟悉之后就轻松多了，考试什么的完全不在话下，但是课外也不知道能写个什么东西。然而数学方面总是有很多麻烦，上课完全听不进去，平时写作业都很头疼，考试也复习得很烂，基本都是靠考场上的发挥，强行推导。</p><p>到后面，课本上的东西确实太无聊了，刷了一些 MOOC，感觉还不错，尤其是 Coursera 上的一些课程。一开始以为自己听全英的课是不可能不依赖中文字幕的，后来尝试过才发现有英文字幕就足够了，熟悉后连字幕都不需要。那个时候兴致真的高，即使学校的课排满课表，依然坚持刷几门 MOOC。考虑到我不是那种认真应对考试的人，这些并没有影响到我的 GPA，本来也没有当回事。</p><p>说起来，直到毕业，自己也没有做出来什么项目。那个什么游戏脚本也早就没兴趣了，而且我估计以后也不可能写这种东西，要写也是写强化学习了吧。</p><h3 id="数模"><a class="markdownIt-Anchor" href="#数模"></a> 数模</h3><p>数学建模真的是我大学生活的重要组成部分。入了这个大坑后，接触到很多方面的东西，像建模，编程，写作，排版，算法等，这种交叉性很强的比赛还是很适合我的，或者说我刚好全都占了，所以入门之后就飞起来了。当然了，老师能允许我提前一年参加，也是一个很重要的因素。</p><p>也因为这个，我的寒暑假再也不完整了。各种培训，比赛，完全没有时间做别的事情了。虽然好像我也没有别的事情可以做的。</p><p>有些人觉得数模很水，确实很水，很多渣渣胡搞的东西都能得奖，很多东西明明是造假的也能轻松骗过评委，有些人明明做了不错的东西也可能什么奖都没有。另一方面，每年的题目也不都是合格的。经常会遇到一些老师把自己课题的一部分拿出来当作题目的，这种的还好吧，不是很坑，多少能做，无非就是一些优秀的成果被窃取了。还有那种十分扯淡的题目的，做起来就发现完全没道理，与实际相差十万八千里，没有任何意义的题目，这种就只能认栽了，我能耐着性子给出一个结果就不错了。</p><p>吐槽归吐槽，我多少也从中学到不少东西。从文献检索，数据收集，数据清洗，建模，算法调研与实现，到文献汇总，论文写作与排版，画图制表，这些必备的技能自然不在话下。MATLAB，SAS，Lingo 什么的也都是玩得转的，Office 技能可以说是很专业了。另外，在接触了各种交叉学科的题目后，也学到很多乱七八糟学科的皮毛，让我觉得真的还是数学优美，庆幸自己也算个半吊子的数学专业的学生。</p><h3 id="锻炼身体"><a class="markdownIt-Anchor" href="#锻炼身体"></a> 锻炼身体</h3><p>我一直都怀疑自己高中长身体的时候严重影响了大脑正常工作，导致我成绩非常差，好好学习还会考得更差。</p><p>大学之后，身体好很多了，自己一开始还担心会不会像以前一样天天生病，结果一般一年也就一两次感冒而已。</p><p>体育课本来是我的弱项的，没想到大学体育的成绩居然会很好，让我怀疑是不是其他人太菜了。哦，这倒是真的。</p><p>虽然学校很奇葩，有早操，有环湖跑，很麻烦，但总体还算合理吧。</p><p>另一方面，打篮球可能是我唯一的娱乐活动了。没有高中那么憋屈了，但还是没好到哪儿去。毕竟中锋这种蓝领工作，几乎就是给别人捡球的。到后来强壮一些后，渐渐有了一些球权，但还是很窝囊，很少有人传球。后来实习的时候，自己已经能在野球场上打出一些好球了，可能第一印象还不错吧，多少有了球权了，配合也比较多，打起来还是比较舒心的。</p><p>自己一直都没怎么注意身体损伤，以前崴脚也不当回事儿，直到自己膝盖疼得不能弯曲，终于老实了，知道要保护自己，要适当热身，要纠正不规范的姿势了。大概二十岁就到了养生的年纪了吧，明显感觉到不年轻了，不能瞎折腾了，该好好珍惜了。</p><h3 id="实习"><a class="markdownIt-Anchor" href="#实习"></a> 实习</h3><p>一语成谶，真的就在果壳实习了几乎一年。</p><p>回想起来，真的很不喜欢北京这座城市，却又无可奈何。对租房感到无比头疼，有太多不如意的地方了。回想起自己在学校的时候，觉得吃苦就吃苦吧，实在没条件，以后一定一定要过得舒服，等自己出了校门才知道，还差得远呢，这种憋屈的日子还长长长着呢。</p><p>实习感觉更大程度是自己慢慢学习的过程。从一个学了一堆理论，会写代码却没有什么项目经验的菜鸟，到一个学了更多理论，在实践中慢慢体会软件工程，看起来好像不是菜鸟的菜鸟。自己终究还是复习了很多数学和统计的知识，一点一点规划自己的知识网络，然后不断做项目，总结经验，不断被自己的之前的代码恶心到，不断修改，一点点成长起来。从算法到前后端，不管是哪方面，都有了一定基础了，知道自己能够去挑战一些有难度的东西。</p><p>后来呢，我也不知道自己能去哪里，就留下继续工作了。</p><h3 id="遗憾"><a class="markdownIt-Anchor" href="#遗憾"></a> 遗憾</h3><p>在感情这件事上，真的很遗憾。不光是因为自己最后是单身的，更是因为自己好像已经跑得很偏了。没有什么喜欢的感觉了，更多的可能是对科学的向往，甚至到了“万般皆下品，惟有读书高”的程度。一个人就一个人吧，可悲的是自己一个人的生活简直一团糟，同时还没有什么可能去打破这种困境。</p><p>另一方面，很多比赛也从来没有用心参与过，感觉自己能力到位了，决心总是不到位。</p><p>如果能重来，我大概不会选这样的生活了，一个人确实很难受。但是性格如此，恐怕重来一次，也会一模一样。想要坚守的原则不会变，难受就难受吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时光飞逝，还没来得及好好享受，就已经大学毕业了。&lt;/p&gt;
&lt;p&gt;回想这四年的时光，虽然多是无聊的日子，但多少也有一些值得怀念的记忆。&lt;/p&gt;
&lt;h3 id=&quot;学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#学习&quot;&gt;&lt;/a&gt; 学习&lt;/h3&gt;
&lt;
      
    
    </summary>
    
      <category term="生活" scheme="https://momingcoder.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://momingcoder.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flask 规范化</title>
    <link href="https://momingcoder.github.io/2017/11/19/Flask-%E8%A7%84%E8%8C%83%E5%8C%96/"/>
    <id>https://momingcoder.github.io/2017/11/19/Flask-规范化/</id>
    <published>2017-11-19T15:27:47.000Z</published>
    <updated>2017-11-20T07:32:27.859Z</updated>
    
    <content type="html"><![CDATA[<p>说到 <code>Flask</code> ，这是我接触的第一个后端架构，也基本是目前唯一一个比较熟悉的。</p><p>对于规范化，这当然是很有必要的，特别是你的项目越做越复杂，不断增加新功能的时候，就会发现如果一开始结构很差，基本就需要大规模重构了。而重构，又通常是说说而已，真正动手完全重构什么的是不存在的，这么丑的代码，就算是我自己写得，我也不想再看了。</p><p>所以呢，一开始就尽可能做得规范一点，这样以后看起来就很舒服了，进行修改也会变得相对简单，别人要接手也不会看吐了。</p><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><p>大概长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── docker-compose.yml</div><div class="line">├── Dockerfile</div><div class="line">├── docs</div><div class="line">├── main.py</div><div class="line">├── README.md</div><div class="line">├── requirements.txt</div><div class="line">├── run.sh</div><div class="line">├── app_name</div><div class="line">│   ├── config.py</div><div class="line">│   ├── data</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── static</div><div class="line">│   │   ├── css</div><div class="line">│   │   ├── fonts</div><div class="line">│   │   ├── img</div><div class="line">│   │   └── js</div><div class="line">│   ├── templates</div><div class="line">│   │   ├── index.html</div><div class="line">│   │   ├── layout.html</div><div class="line">│   │   ├── blueprint_1</div><div class="line">│   │   └── blueprint_n</div><div class="line">│   └── blueprints</div><div class="line">│       ├── __init__.py</div><div class="line">│       ├── blueprint_1.py</div><div class="line">│       └── blueprint_n.py</div><div class="line">└── tests</div></pre></td></tr></table></figure><p>先说根目录，一般都用 Docker 的，这里就需要两个配置文件 <code>Dockerfile</code> 和 <code>docker-compose.yml</code> 了；<code>README</code> 当然还是要写的；<code>requirements.txt</code> 里面写上项目用到的各种包；<code>main.py</code> 和 <code>run.sh</code> ，前者是项目的运行文件，后者是考虑如果使用 <code>gunicorn</code> 的话，写到文件里比较省事；<code>docs</code> 和 <code>tests</code> 目录也是需要有的，虽然不是每个人都写测试和文档；最后 <code>app_name</code> ，是整个项目的主体。</p><p>在 <code>app_name</code> 下，每个包含 Python 的文件都需要 <code>__init__.py</code> ，<code>config.py</code> 里面包含项目的各种配置，<code>static</code> ，<code>templates</code> 里面是前端的文件，<code>blueprints</code> 里面包含各个模块的 blueprint。</p><h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h3><p>这里主要说明的是 Blueprint 在项目中的重要作用。</p><p>对于有一定规模的项目来说，通常会有很多不同用途的组件，比如用户登录相关的，API 相关的，某个重要功能相关的等等，这时候利用不同的 Blueprint 加以区分就能够简化整个项目结构，降低模块间的耦合，不管是对于协作开发还是增改功能都有很大益处。</p><p>针对不同的 Blueprint，HTML 文件最好也放置在 <code>template</code> 下不同的文件夹中。</p><p>在使用 Blueprint 的过程中，有几点需要特别注意：</p><ul><li><code>__init__.py</code> 文件并不是摆设，通常里面需要 import 该文件夹下相关的模块，也可以做一些初始化一类的操作，尤其是 <code>app_name</code> 文件夹下的，需要设置各种扩展，以及注册所需的 Blueprint</li><li>使用这种结构的时候，新手很容易发生 Circular import 问题，这个通常是自己没设计好。另外，推荐大家熟悉一下 Python import 的细节，了解一点底层的东西，就能很好解决这个问题了</li><li>推荐所有使用 css/js 的地方都用 <code>url_for</code> 来解决</li></ul><h3 id="常用扩展"><a class="markdownIt-Anchor" href="#常用扩展"></a> 常用扩展</h3><ul><li><code>flask_login</code> 用户登录，做一些权限限制等</li><li><code>flask_sqlalchemy</code> 数据库操作的 ORM</li><li><code>flask_wtf</code> 提供简单的 WTForms 集成，方便控制表单</li><li><code>flask_restful</code> 方便写 RESTful API</li></ul><p>其他的可以浏览 <a href="http://flask.pocoo.org/extensions/" target="_blank" rel="external">Flask Extensions Registry</a>  。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到 &lt;code&gt;Flask&lt;/code&gt; ，这是我接触的第一个后端架构，也基本是目前唯一一个比较熟悉的。&lt;/p&gt;
&lt;p&gt;对于规范化，这当然是很有必要的，特别是你的项目越做越复杂，不断增加新功能的时候，就会发现如果一开始结构很差，基本就需要大规模重构了。而重构，又通常是说说
      
    
    </summary>
    
      <category term="技术" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://momingcoder.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Flask" scheme="https://momingcoder.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="https://momingcoder.github.io/2017/11/18/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://momingcoder.github.io/2017/11/18/Docker-常用命令/</id>
    <published>2017-11-18T12:55:39.000Z</published>
    <updated>2017-11-20T07:32:46.410Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 这几年非常火，只不过对于我这种基本不接触业务的人而言，平时很少会用到 Docker，自己写项目愿意用 Python 的 <code>virtualenv</code> 就不错了。</p><p>对于 Docker，个人了解很肤浅，这里不过是想记录一下自己偶尔需要用到的命令，方便自己使用而已。</p><hr><h3 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h3><p><code>Dockerfile</code> 基本配置如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> docker-images</div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></div><div class="line"><span class="bash">ADD . /app</span></div><div class="line"><span class="bash">RUN pip install -r requirements.txt</span></div><div class="line"><span class="bash">EXPOSE 5000</span></div><div class="line"><span class="bash">ENV NUM_WORKS 4</span></div><div class="line"><span class="bash">CMD [<span class="string">'python3'</span>, <span class="string">'main.py'</span>]</span></div></pre></td></tr></table></figure><p>通过 <code>Dockerfile</code> 来创建 Docker image：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t my-image</div></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 4000:80 my-image</div></pre></td></tr></table></figure><p>Docker 里面各种带 <code>:</code> 的，前面表示的是外部的，后面是镜像里面的。</p><p>停止：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker container stop container_id</div></pre></td></tr></table></figure><p>其他相关命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker container ls</div><div class="line">docker container rm</div><div class="line">docker image ls -a</div><div class="line">docker tag &lt;image&gt; username/repository:tag</div><div class="line">docker push username/repository:tag</div><div class="line">docker run username/repository:tag</div></pre></td></tr></table></figure><h3 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h3><p><code>docker-compose.yml</code> 基本配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">"3"</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">web:</span></div><div class="line"><span class="attr">image:</span> <span class="string">username/repository:tag</span></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">replicas:</span> <span class="number">5</span></div><div class="line"><span class="attr">resources:</span></div><div class="line"><span class="attr">limits:</span></div><div class="line"><span class="attr">cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="attr">memory:</span> <span class="number">50</span><span class="string">M</span></div><div class="line"><span class="attr">restart_policy:</span></div><div class="line"><span class="attr">condition:</span> <span class="string">on-failure</span></div><div class="line"><span class="attr">ports:</span></div><div class="line"><span class="bullet">-</span> <span class="string">"80:80"</span></div><div class="line"><span class="attr">volumes:</span></div><div class="line"><span class="bullet">-</span> <span class="string">"/home/username/data:/data"</span></div><div class="line"><span class="attr">redis:</span></div><div class="line"><span class="attr">image:</span> <span class="string">redis</span></div><div class="line"><span class="attr">ports:</span></div><div class="line"><span class="bullet">-</span> <span class="string">"6379:6379"</span></div><div class="line"><span class="attr">volumes:</span></div><div class="line"><span class="bullet">-</span> <span class="string">"/home/docker/data:/data"</span></div><div class="line"><span class="attr">command:</span> <span class="string">redis-server</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></div></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker swarm init</div></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c docker-compose.yml your_app_name</div></pre></td></tr></table></figure><p>其他：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker service ls</div><div class="line">docker service ps your_app_name</div><div class="line">docker stack rm your_app_name</div><div class="line">docker swarm leave --force</div></pre></td></tr></table></figure><h3 id="compose"><a class="markdownIt-Anchor" href="#compose"></a> Compose</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker-compose up -d --build</div><div class="line">docker-compose stop</div></pre></td></tr></table></figure><p>启动镜像，在镜像里面修改并提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run --name ubuntu_bash -i -t ubuntu-python35 /bin/bash</div><div class="line"><span class="comment"># do something in cmd</span></div><div class="line">docker commit container_id username/repository:tag</div></pre></td></tr></table></figure><p>还有 Swarm 管理和监控等，因为我平时也不用，所以就不写了。</p><p>我发现官方文档比以前好一点了，起码 Tutorial 写得能看了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 这几年非常火，只不过对于我这种基本不接触业务的人而言，平时很少会用到 Docker，自己写项目愿意用 Python 的 &lt;code&gt;virtualenv&lt;/code&gt; 就不错了。&lt;/p&gt;
&lt;p&gt;对于 Docker，个人了解很肤浅，这里不过是想记录一下自己偶尔需
      
    
    </summary>
    
      <category term="技术" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔记" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://momingcoder.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Docker" scheme="https://momingcoder.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>折腾各种工具</title>
    <link href="https://momingcoder.github.io/2017/11/16/%E6%8A%98%E8%85%BE%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7/"/>
    <id>https://momingcoder.github.io/2017/11/16/折腾各种工具/</id>
    <published>2017-11-16T07:39:06.000Z</published>
    <updated>2017-11-16T09:16:50.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>俗话说的好，技术水平不重要，重要的是折腾各种工具的过程。: )</p><p>那么，就来总结一下自己觉得还不错的工具吧。</p><h3 id="chrome"><a class="markdownIt-Anchor" href="#chrome"></a> Chrome</h3><p>先从浏览器说起吧。虽然大家都不相信 “Don’t be eval”，但是目前看来还是 Chrome 比较好用。最近也有 Firefox 速度已经领先的说法，无所谓，暂时懒得换了。</p><ul><li><a href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">JSON Viewer</a> 在浏览器中查看 JSON 格式，支持把返回的 utf-8 编码的字符串变成文本，有各种 theme</li><li><a href="https://chrome.google.com/webstore/detail/its-raining/fkakmejoechmicbecchienoapbakancc?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">It’s Raining</a> 雨声，适合工作的时候听。别跟我扯什么“适合工作的时候听的歌单”、“安静学习的音乐”，我只认白噪声，完全不挑耳机的，当然也可以用来煲耳机</li><li><a href="https://chrome.google.com/webstore/detail/markdown-preview-plus/febilkbfcbhebfnokafefeacimjdckgl?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">Markdown Preview Plus</a> 在浏览器中查看 Markdown</li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US" target="_blank" rel="external">Octotree</a> 显示 GitHub 仓库的目录</li><li><a href="https://chrome.google.com/webstore/detail/polarr-photo-editor/djonnbgfieijldcieafgjcnhmpcfpmgg?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">Polarr Photo Editor</a> 泼辣修图，适合我这种业余人士修改图片格式，进行裁剪什么的（对，我完全不修图的</li><li><a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">Postman</a> 测试 API 接口的，很方便</li><li><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">Vimium</a> Vim 快捷键，不用把手从键盘上移开就可以轻松浏览网页了，非常方便</li></ul><h3 id="跨平台应用"><a class="markdownIt-Anchor" href="#跨平台应用"></a> 跨平台应用</h3><p>当学生的时候主要还是 Windows，毕业了就用 Linux 了，暂时没用过 Mac。</p><ul><li><a href="https://code.visualstudio.com/" target="_blank" rel="external">VS Code</a> 非常好用的编辑器了，一开始关注 Electron 的时候，发现了 Atom，非常棒，后来有了这个就没用过其他的了，反正我开始使用各种语言写代码的时候，已经有这个了，所以一直没试过 Sublime Text。插件是一大特色，很多非常优秀的插件，主题等。各种语言相关的支持插件就不说了<ul><li>找了一下，我以为我应该装了很多的，发现不少优秀的东西都被集成了，比如一些常见的主题，minimap 等</li></ul></li><li><a href="https://www.mendeley.com/" target="_blank" rel="external">Mendeley</a> 论文管理和阅读。缺点是国内同步比较慢，优点是跨平台且免费，完全可以满足基本需求，看论文，做标注，记笔记，管理阅读过的文献</li><li><a href="https://typora.io/" target="_blank" rel="external">Typora</a> Markdown 写作，支持 LaTeX，所见即所得，很方便</li><li><a href="http://store.steampowered.com/" target="_blank" rel="external">Steam</a> 后悔自己毕业了才开始从这里买游戏</li></ul><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>用户最多的操作系统了，最近还是向着好的方向发展的，相对的，Mac 似乎最近口碑很差。</p><ul><li><a href="http://cmder.net/" target="_blank" rel="external">Cmder</a> 一款终端，免安装，可以使用很多常见的命令，现在做得很棒了，个人认为是 Windows 下最好用的终端</li><li><a href="https://www.microsoft.com/en-us/store/p/one-commander/9nblggh4s79b" target="_blank" rel="external">One Commander</a> 文件管理系统，以前用 Clover，广告很难受，就换了这个，启动略慢</li><li>没了。一般软件都先看看 UWP 版本的评价好不好，优先使用 UWP 版。</li></ul><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><p>穷人用这个就挺好的，一般直接 Ubuntu，想折腾就上 Arch，想装黑客可以上 Kali。</p><ul><li><a href="https://github.com/axel-download-accelerator/axel" target="_blank" rel="external">AXEL</a> 下载加速器，一般下载什么包的时候就用上了，可以用来下载百度云盘的东西，不会被限速 200 的</li><li><a href="https://github.com/sharkdp/fd" target="_blank" rel="external">fd</a> Rust 开发的本地文件搜索工具，非常强悍</li><li><a href="https://github.com/soimort/you-get" target="_blank" rel="external">you-get</a> 下载视频、图片的神器，抽空下载好就不用看烦人的广告了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h3&gt;
&lt;p&gt;俗话说的好，技术水平不重要，重要的是折腾各种工具的过程。: )&lt;/p&gt;
&lt;p&gt;那么，就来总结一下自己觉得还不错的工具吧。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="技术" scheme="https://momingcoder.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="https://momingcoder.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>无聊写博客</title>
    <link href="https://momingcoder.github.io/2017/11/05/%E6%97%A0%E8%81%8A%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://momingcoder.github.io/2017/11/05/无聊写博客/</id>
    <published>2017-11-05T08:47:30.000Z</published>
    <updated>2018-01-09T16:38:25.802Z</updated>
    
    <content type="html"><![CDATA[<p>大概一年多没有写博客了。这一年间，多多少少接触了很多工业界的东西，不少东西还是值得记下的。更重要的是，很多东西不记下来自己就忘了，用的时候查资料也不一定方便，毕竟不是每个开源项目的文档都写得那么好用，也只有自己写出来的才最适合自己。</p><p>像很多人一样，开始写博客前都要花很多时间折腾一下。专门的博客服务，<code>WordPress</code>，<code>GitHub Page</code>，完全自己搭建等，基本上都试过了，到头来还是觉得静态页面完全可以满足需求了（是的，变成老实人了呢）。</p><p>另一方面，学习过程中写笔记是很好的习惯，只是一直没有一个合适的笔记应用，我希望是跨平台的，对 <code>Markdown</code> 支持良好，能添加 <code>LaTeX</code> 公式的，速度当然不能慢了。一个个筛选下来，没有一个能满足需求的。不过直接写到博客里面也没有什么不好的，虽说一般笔记是粗糙的知识，博客应该是自己提炼过的，但是想到反正也没人看，自己的博客还不是自己做主嘛，随便瞎写也没关系。</p><p>说到底，也不指望自己能写多少东西，写一点算一点吧，记录一下生活也好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概一年多没有写博客了。这一年间，多多少少接触了很多工业界的东西，不少东西还是值得记下的。更重要的是，很多东西不记下来自己就忘了，用的时候查资料也不一定方便，毕竟不是每个开源项目的文档都写得那么好用，也只有自己写出来的才最适合自己。&lt;/p&gt;
&lt;p&gt;像很多人一样，开始写博客前
      
    
    </summary>
    
      <category term="生活" scheme="https://momingcoder.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="琐事" scheme="https://momingcoder.github.io/tags/%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
</feed>
